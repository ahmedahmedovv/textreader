<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>The Little Prince</title>
    <!-- Primer CSS -->
    <link href="https://unpkg.com/@primer/css@^20.0.0/dist/primer.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Apple Color Emoji', 'Noto Color Emoji', 'Noto Sans', 'Noto Sans CJK SC', 'Noto Sans CJK TC', 'Noto Sans CJK JP', 'Noto Sans CJK KR', 'Noto Sans Arabic', 'Noto Sans Devanagari', 'Noto Sans Hebrew', 'Noto Sans Thai', 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;
            padding: 16px;
            background-color: #f6f8fa;
            -webkit-text-size-adjust: 100%;
            color: #24292f;
        }
        
        #content {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            font-size: 16px;
            line-height: 1.5;
            background: #ffffff;
            padding: 16px;
            border-radius: 6px;
            border: 1px solid #d0d7de;
            box-shadow: 0 1px 3px rgba(27, 31, 35, 0.12);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Apple Color Emoji', 'Noto Color Emoji', 'Noto Sans', 'Noto Sans CJK SC', 'Noto Sans CJK TC', 'Noto Sans CJK JP', 'Noto Sans CJK KR', 'Noto Sans Arabic', 'Noto Sans Devanagari', 'Noto Sans Hebrew', 'Noto Sans Thai', 'Helvetica Neue', Helvetica, Arial, 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', sans-serif;
            unicode-bidi: embed;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        /* Support for right-to-left languages */
        #content[dir="rtl"] {
            direction: rtl;
            text-align: right;
        }
        
        /* Ensure proper rendering of international characters */
        .word {
            font-variant-ligatures: common-ligatures;
            text-rendering: optimizeLegibility;
        }
        
        #content.hello-world {
            min-height: 70vh;
            font-size: 18px;
            font-weight: 400;
            line-height: 1.8;
            text-align: left;
            color: #24292f;
            padding: 40px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        #content.hello-world .word {
            color: #0969da;
            transition: all 0.2s;
        }
        
        
        .word {
            cursor: pointer;
            padding: 1px 1px;
            border-radius: 3px;
            transition: background-color 0.2s;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
        }
        
        .word:active {
            background-color: transparent;
        }
        
        
        /* Highlighted words (selected for definition) */
        .word-highlighted {
            background-color: #0969da !important;
            color: #ffffff !important;
            border-radius: 4px;
            padding: 2px 4px;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(9, 105, 218, 0.3);
        }
        
        .word-highlighted:hover {
            background-color: #0860ca !important;
        }
        
        /* Selection button for multiple words */
        #selection-definition-btn {
            position: fixed;
            display: none;
            background: #0969da;
            color: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(0,0,0,0.4);
            z-index: 10000;
            transition: all 0.2s;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            white-space: nowrap;
            min-width: 160px;
            text-align: center;
        }
        
        #selection-definition-btn:hover {
            background: #0860ca;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }
        
        #selection-definition-btn:active {
            background: #0550ae;
            transform: translateY(0);
        }
        
        #selection-definition-btn.show {
            display: block;
            animation: slideIn 0.2s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Improve text selection */
        #content {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        /* Ensure word spans don't prevent selection */
        #content .word {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        #definition {
            position: fixed;
            top: 16px;
            left: 50%;
            transform: translateX(-50%) translateY(-100px);
            background: #ffffff;
            border: 1px solid #d0d7de;
            box-shadow: 0 8px 24px rgba(140, 149, 159, 0.2);
            display: none;
            z-index: 1000;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 70vh;
            overflow: hidden;
            -webkit-overflow-scrolling: touch;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #definition.show {
            display: block;
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        
        #definition.hidden {
            opacity: 0;
            transform: translateX(-50%) translateY(-100px);
            pointer-events: none;
        }
        
        #definition-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid #d0d7de;
            background: #f6f8fa;
        }
        
        #definition-word {
            font-size: 18px;
            font-weight: 600;
            color: #0969da;
            margin: 0;
        }
        
        #definition .close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: #656d76;
            font-size: 20px;
            line-height: 1;
            padding: 0;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            touch-action: manipulation;
            transition: all 0.2s;
        }
        
        #definition .close:hover {
            background: #f3f4f6;
            color: #24292f;
        }
        
        #definition .close:active {
            background: #eaeef2;
            color: #0969da;
        }
        
        #definition-content {
            padding: 20px;
            font-size: 15px;
            line-height: 1.6;
            color: #24292f;
            overflow-y: auto;
            max-height: calc(70vh - 80px);
        }
        
        #definition-content.loading {
            color: #656d76;
            font-style: italic;
        }
        
        /* Mobile styles */
        @media (max-width: 768px) {
            body {
                padding: 5px;
            }
            
            #content {
                font-size: 18px;
                padding: 12px;
                line-height: 1;
            }
            
            .word {
                padding: 1px 1px;
                min-height: 30px;
                display: inline-block;
            }
            
            #definition {
                top: 10px;
                left: 10px;
                right: 10px;
                transform: translateX(0) translateY(-100px);
                max-width: none;
                width: auto;
                max-height: 60vh;
                border-radius: 12px;
            }
            
            #definition.show {
                transform: translateX(0) translateY(0);
            }
            
            #definition.hidden {
                transform: translateX(0) translateY(-100px);
            }
            
            #definition-header {
                padding: 14px 16px;
            }
            
            #definition-word {
                font-size: 16px;
            }
            
            #definition .close {
                width: 36px;
                height: 36px;
                font-size: 22px;
            }
            
            #definition-content {
                font-size: 15px;
                padding: 16px;
                max-height: calc(70vh - 70px);
            }
        }
        
        /* Very small screens */
        @media (max-width: 480px) {
            #content {
                font-size: 16px;
                padding: 10px;
            }
            
            .word {
                padding: 3px 5px;
            }
            
            #definition {
                padding: 45px 15px 15px 15px;
            }
            
            #definition-content {
                font-size: 16px;
            }
        }
        
        /* Prevent text selection on word tap */
        .word {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Pagination styles */
        #pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 12px;
            margin: 16px 0 8px 0;
            padding: 16px;
            background: #ffffff;
            border-radius: 6px;
            border: 1px solid #d0d7de;
            box-shadow: 0 1px 3px rgba(27, 31, 35, 0.12);
        }
        
        .pagination-btn {
            padding: 5px 16px;
            font-size: 14px;
            font-weight: 500;
            background: #0969da;
            color: #ffffff;
            border: 1px solid #0969da;
            border-radius: 6px;
            cursor: pointer;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            touch-action: manipulation;
            transition: background-color 0.2s, border-color 0.2s;
        }
        
        .pagination-btn:hover {
            background: #0860ca;
            border-color: #0860ca;
        }
        
        .pagination-btn:active {
            background: #0550ae;
            border-color: #0550ae;
        }
        
        .pagination-btn:disabled {
            background: #f6f8fa;
            color: #8c959f;
            border-color: #d0d7de;
            cursor: not-allowed;
        }
        
        #page-info {
            font-size: 14px;
            color: #0969da;
            min-width: 120px;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background-color 0.2s;
            user-select: none;
        }
        
        #page-info:hover {
            background-color: #f3f4f6;
        }
        
        #page-info:active {
            background-color: #e1e4e8;
        }
        
        /* Go to Page Modal */
        #goto-page-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            background: #ffffff;
            border: 1px solid #d0d7de;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(140, 149, 159, 0.2);
            padding: 24px;
            max-width: 400px;
            width: 90%;
            z-index: 1001;
            display: none;
            opacity: 0;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #goto-page-modal.show {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        #goto-page-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #d0d7de;
        }
        
        #goto-page-modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #24292f;
        }
        
        #goto-page-modal .close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: #656d76;
            font-size: 20px;
            line-height: 1;
            padding: 0;
            transition: all 0.2s;
        }
        
        #goto-page-modal .close:hover {
            background: #f3f4f6;
            color: #24292f;
        }
        
        #goto-page-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #24292f;
            margin-bottom: 8px;
        }
        
        #goto-page-input {
            width: 100%;
            padding: 8px 12px;
            font-size: 16px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            color: #24292f;
            box-sizing: border-box;
        }
        
        #goto-page-input:focus {
            outline: none;
            border-color: #0969da;
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.1);
        }
        
        #goto-page-hint {
            font-size: 12px;
            color: #656d76;
            margin-top: 8px;
        }
        
        #goto-page-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }
        
        .goto-page-btn {
            padding: 6px 16px;
            font-size: 14px;
            font-weight: 500;
            border-radius: 6px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .goto-page-btn.primary {
            background: #0969da;
            color: #ffffff;
            border-color: #0969da;
        }
        
        .goto-page-btn.primary:hover {
            background: #0860ca;
            border-color: #0860ca;
        }
        
        .goto-page-btn.secondary {
            background: #f6f8fa;
            color: #24292f;
            border-color: #d0d7de;
        }
        
        .goto-page-btn.secondary:hover {
            background: #f3f4f6;
        }
        
        /* Settings Menu styles */
        #settings-btn {
            position: fixed;
            top: 16px;
            right: 16px;
            width: 48px;
            height: 48px;
            background: #0969da;
            color: #ffffff;
            border: 1px solid #0969da;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(27, 31, 35, 0.12), 0 8px 24px rgba(140, 149, 159, 0.2);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            touch-action: manipulation;
            transition: all 0.2s ease;
            opacity: 1;
            transform: translateY(0);
        }
        
        #settings-btn.hidden {
            opacity: 0;
            transform: translateY(-100px);
            pointer-events: none;
        }
        
        #settings-btn:hover {
            background: #0860ca;
            border-color: #0860ca;
            transform: translateY(0) scale(1.05);
        }
        
        #settings-btn.hidden:hover {
            transform: translateY(-100px) scale(1);
        }
        
        #settings-btn:active {
            transform: translateY(0) scale(0.95);
            background: #0550ae;
            border-color: #0550ae;
        }
        
        #settings-menu {
            position: fixed;
            top: 72px;
            right: 16px;
            background: #ffffff;
            border-radius: 6px;
            border: 1px solid #d0d7de;
            box-shadow: 0 8px 24px rgba(140, 149, 159, 0.2);
            padding: 8px;
            min-width: 280px;
            max-width: 320px;
            z-index: 998;
            display: none;
            flex-direction: column;
            gap: 4px;
            opacity: 0;
            transform: translateY(-8px) scale(0.98);
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #settings-menu.show {
            display: flex;
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .menu-item {
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 500;
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
            touch-action: manipulation;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
        }
        
        .menu-item:hover {
            background-color: #f6f8fa;
        }
        
        .menu-item:active {
            background-color: #f3f4f6;
        }
        
        .menu-item.import {
            background-color: #1a7f37;
            color: #ffffff;
            border-color: #1a7f37;
        }
        
        .menu-item.import:hover {
            background-color: #2da44e;
            border-color: #2da44e;
        }
        
        .menu-item.import:active {
            background-color: #1a7f37;
            border-color: #1a7f37;
        }
        
        .menu-item.export {
            background-color: #0969da;
            color: #ffffff;
            border-color: #0969da;
        }
        
        .menu-item.export:hover {
            background-color: #0860ca;
            border-color: #0860ca;
        }
        
        .menu-item.export:active {
            background-color: #0550ae;
            border-color: #0550ae;
        }
        
        .menu-item.reset {
            background-color: #cf222e;
            color: #ffffff;
            border-color: #cf222e;
        }
        
        .menu-item.reset:hover {
            background-color: #d1242f;
            border-color: #d1242f;
        }
        
        .menu-item.reset:active {
            background-color: #a40e26;
            border-color: #a40e26;
        }
        
        .menu-item-icon {
            font-size: 22px;
            width: 28px;
            text-align: center;
            filter: drop-shadow(0 1px 2px rgba(0,0,0,0.1));
        }
        
        .menu-item span:last-child {
            flex: 1;
            letter-spacing: 0.3px;
        }
        
        #file-input {
            display: none;
        }
        
        .menu-item.prompt {
            background-color: #8250df;
            color: #ffffff;
            border-color: #8250df;
        }
        
        .menu-item.prompt:hover {
            background-color: #7c3aed;
            border-color: #7c3aed;
        }
        
        .menu-item.prompt:active {
            background-color: #6f42c1;
            border-color: #6f42c1;
        }
        
        /* Prompt Settings Modal */
        #prompt-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            background: #ffffff;
            border: 1px solid #d0d7de;
            border-radius: 12px;
            box-shadow: 0 8px 24px rgba(140, 149, 159, 0.2);
            padding: 24px;
            max-width: 600px;
            width: 90%;
            z-index: 1001;
            display: none;
            opacity: 0;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        #prompt-modal.show {
            display: block;
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        
        #prompt-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid #d0d7de;
        }
        
        #prompt-modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: #24292f;
        }
        
        #prompt-modal .close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border-radius: 6px;
            border: none;
            background: transparent;
            color: #656d76;
            font-size: 20px;
            line-height: 1;
            padding: 0;
            transition: all 0.2s;
        }
        
        #prompt-modal .close:hover {
            background: #f3f4f6;
            color: #24292f;
        }
        
        #prompt-label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #24292f;
            margin-bottom: 8px;
        }
        
        #prompt-input {
            width: 100%;
            min-height: 100px;
            padding: 12px;
            font-size: 14px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            resize: vertical;
            color: #24292f;
            line-height: 1.5;
            box-sizing: border-box;
        }
        
        #prompt-input:focus {
            outline: none;
            border-color: #0969da;
            box-shadow: 0 0 0 3px rgba(9, 105, 218, 0.1);
        }
        
        #prompt-default {
            font-size: 12px;
            color: #656d76;
            margin-top: 8px;
            padding: 8px;
            background: #f6f8fa;
            border-radius: 6px;
        }
        
        #prompt-default strong {
            color: #24292f;
        }
        
        #prompt-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 16px;
        }
        
        .prompt-btn {
            padding: 6px 16px;
            font-size: 14px;
            font-weight: 500;
            border-radius: 6px;
            border: 1px solid;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .prompt-btn.primary {
            background: #0969da;
            color: #ffffff;
            border-color: #0969da;
        }
        
        .prompt-btn.primary:hover {
            background: #0860ca;
            border-color: #0860ca;
        }
        
        .prompt-btn.secondary {
            background: #f6f8fa;
            color: #24292f;
            border-color: #d0d7de;
        }
        
        .prompt-btn.secondary:hover {
            background: #f3f4f6;
        }
        
        /* Overlay to close menu when clicking outside */
        #menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(27, 31, 35, 0.5);
            z-index: 997;
            display: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            backdrop-filter: blur(2px);
        }
        
        #menu-overlay.show {
            display: block;
            opacity: 1;
        }
        
        @media (max-width: 768px) {
            #pagination {
                margin: 10px 0;
                padding: 12px;
                gap: 10px;
            }
            
            .pagination-btn {
                padding: 12px 18px;
                font-size: 18px;
            }
            
            #page-info {
                font-size: 18px;
            }
            
            #settings-btn {
                width: 55px;
                height: 55px;
                font-size: 26px;
                top: 10px;
                right: 10px;
            }
            
            #settings-menu {
                top: 70px;
                right: 10px;
                left: 10px;
                min-width: auto;
                max-width: none;
                padding: 8px;
                border-radius: 6px;
            }
            
            .menu-item {
                padding: 12px 16px;
                font-size: 16px;
                border-radius: 6px;
                gap: 12px;
            }
            
            .menu-item-icon {
                font-size: 20px;
                width: 24px;
            }
            
            #menu-overlay {
                background: rgba(27, 31, 35, 0.6);
            }
            
            #content.hello-world {
                font-size: 16px;
                min-height: 60vh;
                padding: 20px;
                line-height: 1.7;
            }
        }
        
        @media (max-width: 480px) {
            #content.hello-world {
                font-size: 15px;
                min-height: 50vh;
                padding: 16px;
                line-height: 1.6;
            }
            
            #prompt-modal {
                padding: 16px;
                max-width: 95%;
            }
            
            #prompt-modal-header h3 {
                font-size: 16px;
            }
            
            #prompt-input {
                min-height: 80px;
                font-size: 14px;
            }
            
            #goto-page-modal {
                padding: 16px;
                max-width: 95%;
            }
            
            #goto-page-modal-header h3 {
                font-size: 16px;
            }
            
            #goto-page-input {
                font-size: 16px; /* Prevents zoom on iOS */
                padding: 10px 12px;
            }
            
            #selection-definition-btn {
                padding: 12px 20px;
                font-size: 16px;
                min-width: 160px;
                border-radius: 10px;
                box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            }
        }
    </style>
</head>
<body>
    <div id="definition">
        <div id="definition-header">
            <h3 id="definition-word"></h3>
            <button class="close" onclick="closeDefinition()" aria-label="Close">√ó</button>
        </div>
        <div id="definition-content" class="loading">Loading definition...</div>
    </div>
    
    <button id="selection-definition-btn" onclick="getDefinitionForSelection(event)">üìñ Get Definition</button>
    
    <button id="settings-btn" onclick="toggleSettingsMenu()" title="Settings">‚öôÔ∏è</button>
    <div id="menu-overlay" onclick="closeSettingsMenu(); closePromptSettings(); closeGotoPageModal();"></div>
    <div id="settings-menu">
        <input type="file" id="file-input" accept=".txt,.pdf" onchange="importFile(event)">
        <button class="menu-item import" onclick="document.getElementById('file-input').click(); closeSettingsMenu();">
            <span class="menu-item-icon">üì•</span>
            <span>Import Text</span>
        </button>
        <button class="menu-item export" onclick="exportText(); closeSettingsMenu();">
            <span class="menu-item-icon">üì§</span>
            <span>Export Text</span>
        </button>
        <button class="menu-item reset" onclick="resetToDefault(); closeSettingsMenu();">
            <span class="menu-item-icon">üîÑ</span>
            <span>Reset to Default</span>
        </button>
        <button class="menu-item prompt" onclick="openPromptSettings(); closeSettingsMenu();">
            <span class="menu-item-icon">ü§ñ</span>
            <span>AI Prompt Settings</span>
        </button>
    </div>
    
    <!-- Prompt Settings Modal -->
    <div id="prompt-modal">
        <div id="prompt-modal-header">
            <h3>AI Prompt Settings</h3>
            <button class="close" onclick="closePromptSettings()" aria-label="Close">√ó</button>
        </div>
        <label for="prompt-input" id="prompt-label">Custom Prompt (use {word} as placeholder for the word):</label>
        <textarea id="prompt-input" placeholder="Enter your custom prompt..."></textarea>
        <div id="prompt-default">
            <strong>Default prompt:</strong> Give me a brief English definition of the word: {word}
        </div>
        <div id="prompt-actions">
            <button class="prompt-btn secondary" onclick="resetPrompt()">Reset to Default</button>
            <button class="prompt-btn primary" onclick="savePrompt()">Save</button>
        </div>
    </div>
    <pre id="content">Loading...</pre>
    <div id="pagination" style="display: none;">
        <button class="pagination-btn" id="prev-btn" onclick="previousPage()">Previous</button>
        <span id="page-info" onclick="openGotoPageModal()" title="Click to go to a specific page">Page 1 of 1</span>
        <button class="pagination-btn" id="next-btn" onclick="nextPage()">Next</button>
    </div>
    
    <!-- Go to Page Modal -->
    <div id="goto-page-modal">
        <div id="goto-page-modal-header">
            <h3>Go to Page</h3>
            <button class="close" onclick="closeGotoPageModal()" aria-label="Close">√ó</button>
        </div>
        <label for="goto-page-input" id="goto-page-label">Enter page number:</label>
        <input type="number" id="goto-page-input" min="1" placeholder="Page number" autofocus>
        <div id="goto-page-hint"></div>
        <div id="goto-page-actions">
            <button class="goto-page-btn secondary" onclick="closeGotoPageModal()">Cancel</button>
            <button class="goto-page-btn primary" onclick="goToPageNumber()">Go</button>
        </div>
    </div>
    
    <script>
        // API endpoint - uses Netlify function to hide API key
        const DEFINITION_API_URL = '/.netlify/functions/get-definition';
        // For local development - API key (only used if Netlify function is not available)
        const MISTRAL_API_KEY = 'aUyFZtjZY3r5aNe1th2qtx6IBLynCc0ai';
        const MISTRAL_API_URL = 'https://api.mistral.ai/v1/chat/completions';
        
        let pages = [];
        let currentPhrase = []; // Track clicked adjacent words to form a phrase
        let currentPhraseElements = []; // Track word elements in same order as currentPhrase
        let lastClickedWordElement = null; // Track last clicked word element
        let highlightedWordElements = []; // Track highlighted word elements
        let currentPage = 0;
        let originalText = ''; // Store original text for export
        const LINES_PER_PAGE = 50; // Adjust this to change page size

        function toggleSettingsMenu() {
            const menu = document.getElementById('settings-menu');
            const overlay = document.getElementById('menu-overlay');
            const isOpen = menu.classList.contains('show');
            
            if (isOpen) {
                closeSettingsMenu();
            } else {
                menu.classList.add('show');
                overlay.classList.add('show');
            }
        }
        
        function closeSettingsMenu() {
            document.getElementById('settings-menu').classList.remove('show');
            document.getElementById('menu-overlay').classList.remove('show');
        }
        
        const DEFAULT_PROMPT = 'Give me a brief English definition of the word: {word}';
        
        function getPrompt() {
            const savedPrompt = localStorage.getItem('customPrompt');
            return savedPrompt || DEFAULT_PROMPT;
        }
        
        function openPromptSettings() {
            const modal = document.getElementById('prompt-modal');
            const promptInput = document.getElementById('prompt-input');
            const currentPrompt = getPrompt();
            
            promptInput.value = currentPrompt;
            modal.classList.add('show');
            document.getElementById('menu-overlay').classList.add('show');
        }
        
        function closePromptSettings() {
            document.getElementById('prompt-modal').classList.remove('show');
            document.getElementById('menu-overlay').classList.remove('show');
        }
        
        function savePrompt() {
            const promptInput = document.getElementById('prompt-input');
            const customPrompt = promptInput.value.trim();
            
            if (customPrompt) {
                localStorage.setItem('customPrompt', customPrompt);
                closePromptSettings();
            } else {
                alert('Please enter a prompt');
            }
        }
        
        function resetPrompt() {
            document.getElementById('prompt-input').value = DEFAULT_PROMPT;
            localStorage.removeItem('customPrompt');
        }

        // Helper function to format file size
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // Check localStorage quota
        function checkLocalStorageQuota() {
            try {
                const test = 'test';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Estimate localStorage usage
        function estimateLocalStorageUsage(text) {
            // Rough estimate: each character is ~1-2 bytes, plus localStorage overhead
            return new Blob([text]).size;
        }
        
        async function importFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Check file size (warn if > 5MB)
            const MAX_RECOMMENDED_SIZE = 5 * 1024 * 1024; // 5MB
            const MAX_SIZE = 10 * 1024 * 1024; // 10MB hard limit
            
            if (file.size > MAX_SIZE) {
                alert(`File is too large (${formatFileSize(file.size)}). Maximum file size is ${formatFileSize(MAX_SIZE)}. Please use a smaller file.`);
                event.target.value = '';
                return;
            }
            
            if (file.size > MAX_RECOMMENDED_SIZE) {
                const proceed = confirm(`Warning: This file is large (${formatFileSize(file.size)}). Large files may take longer to process and could exceed browser storage limits. Continue anyway?`);
                if (!proceed) {
                    event.target.value = '';
                    return;
                }
            }
            
            const fileName = file.name.toLowerCase();
            const isPDF = fileName.endsWith('.pdf');
            
            // Show loading indicator
            const loadingMsg = document.createElement('div');
            loadingMsg.id = 'import-loading';
            loadingMsg.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); z-index: 10000; text-align: center;';
            loadingMsg.innerHTML = `<div style="margin-bottom: 10px;">üìÑ Processing file...</div><div style="font-size: 12px; color: #656d76;">${formatFileSize(file.size)}</div>`;
            document.body.appendChild(loadingMsg);
            
            let text = '';
            
            if (isPDF) {
                // Handle PDF file with formatting preservation
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                    const numPages = pdf.numPages;
                    let fullText = '';
                    
                    // Extract text from all pages with formatting
                    for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                        const page = await pdf.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        
                        // Group text items by Y position to preserve line structure
                        const viewport = page.getViewport({ scale: 1.0 });
                        const lines = [];
                        const lineMap = new Map();
                        
                        textContent.items.forEach((item, index) => {
                            const y = Math.round(item.transform[5]);
                            
                            if (!lineMap.has(y)) {
                                lineMap.set(y, []);
                            }
                            lineMap.get(y).push({
                                text: item.str,
                                x: item.transform[4],
                                width: item.width,
                                height: item.height
                            });
                        });
                        
                        // Sort lines by Y position (top to bottom)
                        const sortedLines = Array.from(lineMap.entries())
                            .sort((a, b) => b[0] - a[0]); // Higher Y values first (PDF coordinates)
                        
                        let lastY = null;
                        let lastLineHeight = null;
                        sortedLines.forEach(([y, items]) => {
                            const lineHeight = items[0] ? items[0].height : 12;
                            
                            // Check if this is a new paragraph (significant Y difference)
                            if (lastY !== null) {
                                const yDiff = lastY - y;
                                const avgHeight = lastLineHeight ? (lastLineHeight + lineHeight) / 2 : lineHeight;
                                
                                // If Y difference is more than 1.5x the average line height, it's a paragraph break
                                if (yDiff > avgHeight * 1.5) {
                                    fullText += '\n';
                                }
                            }
                            
                            lastLineHeight = lineHeight;
                            
                            // Sort items in line by X position (left to right)
                            items.sort((a, b) => a.x - b.x);
                            
                            // Build the line text with proper spacing
                            let lineText = '';
                            let lastXEnd = null;
                            
                            items.forEach((item, idx) => {
                                // Calculate spacing between items
                                if (lastXEnd !== null) {
                                    const gap = item.x - lastXEnd;
                                    // Add space if gap is significant (more than 20% of item width)
                                    if (gap > item.width * 0.2) {
                                        // Add multiple spaces for larger gaps (indentation)
                                        const spaces = gap > item.width * 2 ? '  ' : ' ';
                                        lineText += spaces;
                                    }
                                }
                                lineText += item.text;
                                lastXEnd = item.x + item.width;
                            });
                            
                            fullText += lineText + '\n';
                            lastY = y;
                        });
                        
                        // Add page break between pages
                        if (pageNum < numPages) {
                            fullText += '\n\n';
                        }
                    }
                    
                    text = fullText.trim();
                } catch (error) {
                    document.body.removeChild(loadingMsg);
                    alert('Error reading PDF file: ' + error.message);
                    event.target.value = '';
                    return;
                }
            } else {
                // Handle text file with automatic encoding detection
                try {
                    // Try multiple encodings - Windows-1252 is very common for files with special characters
                    const encodings = [
                        'windows-1252',  // Try this first - handles curly quotes, Euro, trademark, etc.
                        'UTF-8',
                        '',              // Browser default
                        'ISO-8859-1',    // Latin-1
                        'ISO-8859-15'    // Latin-9
                    ];
                    
                    let decoded = false;
                    let bestResult = null;
                    let bestScore = -1;
                    
                    // Try each encoding and score the result
                    for (const encoding of encodings) {
                        try {
                            const reader = new FileReader();
                            const result = await new Promise((resolve, reject) => {
                                reader.onload = function(e) {
                                    resolve(e.target.result);
                                };
                                reader.onerror = function(error) {
                                    reject(error);
                                };
                                
                                if (encoding) {
                                    reader.readAsText(file, encoding);
                                } else {
                                    reader.readAsText(file); // Browser default
                                }
                            });
                            
                            // Score the result: fewer replacement characters = better
                            const replacementCharCount = (result.match(/\uFFFD/g) || []).length;
                            const totalChars = result.length;
                            const score = totalChars > 0 ? 1 - (replacementCharCount / totalChars) : 0;
                            
                            // Check for common UTF-8 misinterpretation patterns (like "√¢‚Ç¨‚Ñ¢", "don√¢'t")
                            const hasUTF8Misinterpretation = /√¢[‚Ç¨‚Ñ¢‚Ç¨"‚Äì‚Äî‚Ä¶‚Ñ¢‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í≈Ω''""‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì≈æ≈∏]/g.test(result);
                            
                            // Check for common encoding artifacts
                            const hasEncodingArtifacts = /[‚Ç¨‚Ñ¢‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í≈Ω''""‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì≈æ≈∏]/g.test(result);
                            
                            // Penalize UTF-8 misinterpretations heavily
                            const finalScore = hasUTF8Misinterpretation ? score * 0.5 : score;
                            
                            if (finalScore > bestScore) {
                                bestResult = result;
                                bestScore = finalScore;
                                
                                // If we found a good result with Windows-1252 and no UTF-8 misinterpretations, use it immediately
                                if (encoding === 'windows-1252' && score > 0.99 && !hasUTF8Misinterpretation) {
                                    text = result;
                                    decoded = true;
                                    console.log('Using Windows-1252 encoding (best match, no misinterpretations)');
                                    break;
                                }
                            }
                            
                        } catch (e) {
                            // Continue to next encoding
                            continue;
                        }
                    }
                    
                    // Use the best result we found
                    if (!decoded && bestResult) {
                        text = bestResult;
                        decoded = true;
                        console.log(`Using best encoding match (score: ${(bestScore * 100).toFixed(1)}%)`);
                    }
                    
                    // If still not decoded, use UTF-8 as final fallback
                    if (!decoded) {
                        console.warn('Using UTF-8 fallback');
                        const reader = new FileReader();
                        await new Promise((resolve, reject) => {
                            reader.onload = function(e) {
                                text = e.target.result;
                                decoded = true;
                                resolve();
                            };
                            reader.onerror = reject;
                            reader.readAsText(file, 'UTF-8');
                        });
                    }
                    
                    // Check if the result has UTF-8 misinterpretation patterns
                    // If so, try Windows-1252 one more time as it's likely the correct encoding
                    const hasMisinterpretation = /√¢[‚Ç¨‚Ñ¢‚Ç¨"‚Äì‚Äî‚Ä¶‚Ñ¢‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í≈Ω''""‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì≈æ≈∏]|(\w+)√¢'t/g.test(text);
                    if (hasMisinterpretation && text !== bestResult) {
                        console.log('Detected UTF-8 misinterpretation patterns, trying Windows-1252 again...');
                        try {
                            const reader = new FileReader();
                            const win1252Result = await new Promise((resolve, reject) => {
                                reader.onload = function(e) {
                                    resolve(e.target.result);
                                };
                                reader.onerror = reject;
                                reader.readAsText(file, 'windows-1252');
                            });
                            
                            // Check if Windows-1252 result is better (no misinterpretation patterns)
                            const hasWin1252Misinterpretation = /√¢[‚Ç¨‚Ñ¢‚Ç¨"‚Äì‚Äî‚Ä¶‚Ñ¢‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í≈Ω''""‚Äì‚ÄîÀú‚Ñ¢≈°‚Ä∫≈ì≈æ≈∏]|(\w+)√¢'t/g.test(win1252Result);
                            if (!hasWin1252Misinterpretation) {
                                text = win1252Result;
                                console.log('Switched to Windows-1252 encoding (fixes misinterpretations)');
                            }
                        } catch (e) {
                            // If Windows-1252 fails, keep the original result
                            console.warn('Could not retry with Windows-1252:', e);
                        }
                    }
                    
                    // Apply common encoding fixes (fixes smart quotes, etc.)
                    text = fixCommonEncodingIssues(text);
                    
                } catch (error) {
                    document.body.removeChild(loadingMsg);
                    alert('Error reading text file: ' + error.message + '\n\nTip: If you see incorrect characters, try saving your file as UTF-8 in your text editor before importing.');
                    event.target.value = '';
                    return;
                }
            }
            
            // Check text size before saving
            const textSize = estimateLocalStorageUsage(text);
            const estimatedSizeMB = textSize / (1024 * 1024);
            
            if (estimatedSizeMB > 8) {
                document.body.removeChild(loadingMsg);
                const proceed = confirm(`Warning: The extracted text is very large (approximately ${formatFileSize(textSize)}). This may exceed browser storage limits and cause the import to fail. Continue anyway?`);
                if (!proceed) {
                    event.target.value = '';
                    return;
                }
            }
            
            // Process the extracted text
            originalText = text;
            
            // Save imported text to localStorage with error handling
            try {
                // Check if we can write to localStorage
                if (!checkLocalStorageQuota()) {
                    throw new Error('Browser storage is full or unavailable');
                }
                
                localStorage.setItem('importedText', text);
            } catch (error) {
                document.body.removeChild(loadingMsg);
                
                // Check if it's a quota exceeded error
                if (error.name === 'QuotaExceededError' || error.message.includes('quota') || error.message.includes('full')) {
                    alert(`Storage limit exceeded! The file is too large (${formatFileSize(textSize)}) to save in browser storage.\n\nMaximum recommended size: ~5MB\n\nTry:\n- Using a smaller file\n- Splitting the file into parts\n- Using a different browser`);
                } else {
                    alert('Error saving file: ' + error.message);
                }
                event.target.value = '';
                return;
            }
            
            pages = splitIntoPages(text);
            if (pages.length > 1) {
                document.getElementById('pagination').style.display = 'flex';
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
            // Reset to first page when importing new file
            currentPage = 0;
            localStorage.setItem('currentPage', 0);
            displayPage(0);
            
            // Remove loading indicator
            document.body.removeChild(loadingMsg);
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: #2da44e; color: white; padding: 12px 20px; border-radius: 6px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); z-index: 10000; font-size: 14px;';
            successMsg.textContent = `‚úì File imported successfully (${formatFileSize(textSize)})`;
            document.body.appendChild(successMsg);
            setTimeout(() => {
                if (document.body.contains(successMsg)) {
                    document.body.removeChild(successMsg);
                }
            }, 3000);
            
            // Reset file input so same file can be selected again
            event.target.value = '';
        }
        
        // Fix common encoding issues (smart quotes, special characters)
        function fixCommonEncodingIssues(text) {
            // Common Windows-1252 to UTF-8 mapping issues
            // These are characters that often get misinterpreted when Windows-1252 is read as UTF-8
            const fixes = [
                // Smart quotes and apostrophes (most common issue)
                [/\u2018/g, "'"],  // Left single quotation mark ‚Üí apostrophe
                [/\u2019/g, "'"],  // Right single quotation mark ‚Üí apostrophe
                [/\u201C/g, '"'],  // Left double quotation mark ‚Üí quote
                [/\u201D/g, '"'],  // Right double quotation mark ‚Üí quote
                [/\u201A/g, ','],  // Single low-9 quotation mark ‚Üí comma
                [/\u201E/g, '"'],  // Double low-9 quotation mark ‚Üí quote
                [/\u2032/g, "'"],  // Prime ‚Üí apostrophe
                [/\u2033/g, '"'],  // Double prime ‚Üí quote
                
                // Fix UTF-8 misinterpretations of Windows-1252 characters
                // These patterns handle cases where Windows-1252 bytes are read as UTF-8
                [/√¢‚Ç¨‚Ñ¢/g, "'"],     // UTF-8 misinterpretation of Windows-1252 apostrophe (0x92)
                [/√¢‚Ç¨≈ì/g, '"'],     // UTF-8 misinterpretation of left quote (0x93)
                [/√¢‚Ç¨/g, '"'],      // UTF-8 misinterpretation of right quote (0x94)
                [/√¢‚Ç¨"/g, '"'],     // UTF-8 misinterpretation of right quote (variant)
                [/√¢‚Ç¨"/g, '"'],     // Another variant
                [/√¢‚Ç¨"/g, '"'],     // Another variant
                
                // More comprehensive patterns for apostrophes
                // Handle "don√¢'t" ‚Üí "don't" (the √¢ is part of the UTF-8 misinterpretation)
                // These patterns catch various misinterpretations of Windows-1252 apostrophe (0x92)
                [/don√¢'t/g, "don't"],     // Specific case: "don't"
                [/(\w+)√¢'t/g, "$1't"],   // General pattern: word + √¢'t ‚Üí word + 't (e.g., "can√¢'t" ‚Üí "can't")
                [/(\w+)√¢‚Ç¨‚Ñ¢/g, "$1'"],    // General pattern: word + √¢‚Ç¨‚Ñ¢ ‚Üí word + ' (e.g., "won√¢‚Ç¨‚Ñ¢t" ‚Üí "won't")
                [/(\w+)√¢‚Ç¨"/g, '$1"'],    // General pattern for quotes
                // Handle cases where √¢ is followed by other characters that form the misinterpreted apostrophe
                [/(\w+)√¢([^a-zA-Z0-9\s])t/g, "$1$2t"],  // word + √¢ + char + t ‚Üí word + char + t
                // More aggressive: any word followed by √¢ and then 't
                [/([a-zA-Z]+)√¢'t/g, "$1't"],
                
                // Handle standalone misinterpreted sequences
                [/√¢‚Ç¨‚Ñ¢/g, "'"],      // Standalone misinterpreted apostrophe
                [/√¢‚Ç¨≈ì/g, '"'],      // Standalone misinterpreted left quote
                [/√¢‚Ç¨"/g, '"'],      // Standalone misinterpreted right quote
                
                // Fix other common Windows-1252 characters misinterpreted as UTF-8
                [/√¢‚Ç¨"/g, '‚Äî'],      // Em dash
                [/√¢‚Ç¨"/g, '‚Äì'],      // En dash
                [/√¢‚Ç¨¬¶/g, '...'],    // Ellipsis
                [/√¢‚Ç¨"/g, '‚Ç¨'],      // Euro symbol
                [/√¢‚Äû¬¢/g, '‚Ñ¢'],      // Trademark
                [/√¢‚Ç¨"/g, '‚Ä¶'],      // Horizontal ellipsis (another variant)
                
                // Dashes
                [/\u2013/g, '-'],  // En dash ‚Üí hyphen
                [/\u2014/g, '--'], // Em dash ‚Üí double hyphen
                
                // Other common issues
                [/\u2026/g, '...'], // Horizontal ellipsis ‚Üí three dots
                [/\u00A0/g, ' '],  // Non-breaking space ‚Üí regular space
            ];
            
            let fixed = text;
            
            // Apply fixes in order
            fixes.forEach(([pattern, replacement]) => {
                fixed = fixed.replace(pattern, replacement);
            });
            
            // Additional pass: fix any remaining "√¢" followed by common patterns
            // This catches cases where the encoding wasn't detected correctly
            fixed = fixed.replace(/√¢([‚Ç¨‚Ñ¢‚Ç¨"‚Äì‚Äî‚Ä¶‚Ñ¢])/g, (match, char) => {
                const map = {
                    '‚Ç¨‚Ñ¢': "'",
                    '‚Ç¨': '‚Ç¨',
                    '"': '"',
                    '‚Äì': '-',
                    '‚Äî': '--',
                    '‚Ä¶': '...',
                    '‚Ñ¢': '‚Ñ¢'
                };
                return map[char] || match;
            });
            
            // Final aggressive pass: fix "word√¢'t" ‚Üí "word't" patterns
            // This handles cases like "don√¢'t" ‚Üí "don't"
            // The pattern matches: word character(s) + "√¢" + any character + "t"
            fixed = fixed.replace(/(\w+)√¢([^a-zA-Z0-9])t/g, "$1$2t");
            // More specific: "word√¢'t" ‚Üí "word't"
            fixed = fixed.replace(/(\w+)√¢'t/g, "$1't");
            // Even more specific: "word√¢‚Ç¨‚Ñ¢" ‚Üí "word'"
            fixed = fixed.replace(/(\w+)√¢‚Ç¨‚Ñ¢/g, "$1'");
            
            // Fix standalone "√¢" that might be part of misinterpreted sequences
            // Only if it's followed by characters that suggest it's an encoding error
            fixed = fixed.replace(/√¢([‚Ç¨‚Ñ¢‚Äö∆í‚Äû‚Ä¶‚Ä†‚Ä°ÀÜ‚Ä∞≈†‚Äπ≈í≈Ω])/g, (match, char) => {
                // These are common Windows-1252 characters that get misinterpreted
                const charMap = {
                    '‚Ç¨‚Ñ¢': "'",  // Apostrophe
                    '‚Ç¨': '‚Ç¨',   // Euro
                    '"': '"',   // Quote
                    '‚Äö': ',',   // Single low-9 quotation mark
                    '∆í': 'f',   // Latin small f with hook
                    '‚Äû': '"',   // Double low-9 quotation mark
                    '‚Ä¶': '...', // Horizontal ellipsis
                    '‚Ä†': '+',   // Dagger
                    '‚Ä°': '++',  // Double dagger
                    'ÀÜ': '^',   // Modifier letter circumflex accent
                    '‚Ä∞': '%',   // Per mille sign
                    '≈†': 'S',   // Latin capital S with caron
                    '‚Äπ': '<',   // Single left-pointing angle quotation mark
                    '≈í': 'OE',  // Latin capital ligature OE
                    '≈Ω': 'Z',   // Latin capital Z with caron
                };
                return charMap[char] || match;
            });
            
            return fixed;
        }
        
        // Detect if text contains RTL (Right-to-Left) characters
        function detectTextDirection(text) {
            // RTL Unicode ranges: Arabic, Hebrew, Persian, Urdu, etc.
            const rtlPattern = /[\u0590-\u05FF\u0600-\u06FF\u0700-\u074F\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
            // Check first 1000 characters for performance
            const sample = text.substring(0, Math.min(1000, text.length));
            return rtlPattern.test(sample) ? 'rtl' : 'ltr';
        }
        
        function loadText(text) {
            originalText = text;
            
            // Detect and set text direction for international support
            const textDirection = detectTextDirection(text);
            const contentDiv = document.getElementById('content');
            contentDiv.setAttribute('dir', textDirection);
            
            pages = splitIntoPages(text);
            if (pages.length > 1) {
                document.getElementById('pagination').style.display = 'flex';
            } else {
                document.getElementById('pagination').style.display = 'none';
            }
            // Restore saved page or default to first page
            const savedPage = getSavedPage();
            const pageToLoad = savedPage < pages.length ? savedPage : 0;
            displayPage(pageToLoad);
        }
        
        function exportText() {
            if (!originalText) {
                alert('No text to export');
                return;
            }
            
            // Create blob with UTF-8 encoding for international characters
            const blob = new Blob([originalText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'exported-text.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function resetToDefault() {
            // Clear imported text from localStorage
            localStorage.removeItem('importedText');
            localStorage.setItem('currentPage', 0);
            // Reload the page to show welcome message
            location.reload();
        }

        // Track mouse state for selection detection
        let isSelecting = false;
        let mouseDownTime = 0;
        let mouseDownPos = { x: 0, y: 0 };
        
        // Mobile touch state for scroll detection
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };
        let touchStartScrollY = 0;
        let isScrolling = false;
        let touchMoved = false;
        let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
        
        function makeWordsClickable(text) {
            // Split text into words while preserving spaces and line breaks
            // Use data attributes instead of onclick to allow text selection
            return text.replace(/(\S+)/g, function(match) {
                // Escape quotes in the word for data attribute
                const escaped = match.replace(/'/g, "&#39;").replace(/"/g, '&quot;');
                return '<span class="word" data-word="' + escaped + '">' + match + '</span>';
            });
        }
        
        // Initialize word click handlers after content is loaded
        function initWordClicks() {
            const contentDiv = document.getElementById('content');
            if (!contentDiv) return;
            
            // Remove old listeners if any
            contentDiv.removeEventListener('mousedown', handleWordMouseDown);
            contentDiv.removeEventListener('mouseup', handleWordMouseUp);
            contentDiv.removeEventListener('click', handleWordClick);
            contentDiv.removeEventListener('touchstart', handleWordTouchStart, { passive: true });
            contentDiv.removeEventListener('touchmove', handleWordTouchMove, { passive: true });
            contentDiv.removeEventListener('touchend', handleWordTouchEnd, { passive: true });
            
            if (isMobileDevice) {
                // Mobile: use touch events with scroll detection
                contentDiv.addEventListener('touchstart', handleWordTouchStart, { passive: true });
                contentDiv.addEventListener('touchmove', handleWordTouchMove, { passive: true });
                contentDiv.addEventListener('touchend', handleWordTouchEnd, { passive: true });
            } else {
                // Desktop: use mouse events
                contentDiv.addEventListener('mousedown', handleWordMouseDown);
                contentDiv.addEventListener('mouseup', handleWordMouseUp);
                contentDiv.addEventListener('click', handleWordClick);
            }
        }
        
        // Mobile touch handlers
        function handleWordTouchStart(event) {
            const wordElement = event.target.closest('.word');
            if (wordElement) {
                touchStartTime = Date.now();
                const touch = event.touches[0];
                touchStartPos = { x: touch.clientX, y: touch.clientY };
                touchStartScrollY = window.pageYOffset || document.documentElement.scrollTop;
                isScrolling = false;
                touchMoved = false;
            } else {
                touchStartPos = { x: 0, y: 0 };
            }
        }
        
        function handleWordTouchMove(event) {
            if (touchStartPos.x === 0 && touchStartPos.y === 0) return;
            
            const touch = event.touches[0];
            const moveX = Math.abs(touch.clientX - touchStartPos.x);
            const moveY = Math.abs(touch.clientY - touchStartPos.y);
            
            // If movement is significant, it's likely scrolling
            if (moveX > 5 || moveY > 5) {
                touchMoved = true;
                // Check if vertical movement is significant (scrolling)
                if (moveY > 10) {
                    isScrolling = true;
                }
            }
        }
        
        function handleWordTouchEnd(event) {
            const wordElement = event.target.closest('.word');
            if (!wordElement) {
                isScrolling = false;
                touchMoved = false;
                return;
            }
            
            // Wait a bit to check if scrolling occurred
            setTimeout(() => {
                // Check if page scrolled during touch
                const currentScrollY = window.pageYOffset || document.documentElement.scrollTop;
                const scrolledDuringTouch = Math.abs(currentScrollY - touchStartScrollY) > 5;
                
                // Check if there's a text selection
                const selection = window.getSelection();
                const hasSelection = selection.toString().trim().length > 0;
                
                if (hasSelection) {
                    isSelecting = true;
                    handleTextSelection();
                    isScrolling = false;
                    touchMoved = false;
                    return;
                }
                
                const touch = event.changedTouches[0];
                const touchDuration = Date.now() - touchStartTime;
                const touchMove = Math.abs(touch.clientX - touchStartPos.x) + Math.abs(touch.clientY - touchStartPos.y);
                
                // Only process as click if:
                // - NOT scrolling (most important)
                // - NOT scrolled during touch
                // - Movement is minimal (less than 10px)
                // - Touch duration is reasonable (100-800ms)
                // - No text selection
                if (!isScrolling && !scrolledDuringTouch && !touchMoved && touchMove < 10 && touchDuration >= 100 && touchDuration <= 800 && !hasSelection) {
                    // This is a deliberate tap, process word click
                    const word = wordElement.getAttribute('data-word');
                    if (word) {
                        // Decode HTML entities
                        const decodedWord = word.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                        
                        // Check if this word is adjacent to the last clicked word
                        const isAdjacent = checkIfAdjacent(wordElement, lastClickedWordElement);
                        
                        if (isAdjacent && lastClickedWordElement && currentPhrase.length > 0) {
                            // Add word to current phrase (order will be sorted)
                            currentPhrase.push(decodedWord);
                            currentPhraseElements.push(wordElement);
                            lastClickedWordElement = wordElement;
                            // Highlight the new word
                            highlightWord(wordElement);
                            // Sort phrase to maintain left-to-right reading order
                            sortPhraseLeftToRight();
                            // Get definition for merged phrase (now in correct order)
                            const mergedPhrase = currentPhrase.join(' ');
                            getDefinition(mergedPhrase);
                        } else {
                            // New word (not adjacent), start new phrase
                            // Clear previous highlights
                            clearHighlights();
                            // Start new phrase
                            currentPhrase = [decodedWord];
                            currentPhraseElements = [wordElement];
                            lastClickedWordElement = wordElement;
                            // Highlight the new word
                            highlightWord(wordElement);
                            getDefinition(decodedWord);
                        }
                    }
                }
                
                // Reset flags
                isScrolling = false;
                touchMoved = false;
            }, 150); // Delay to detect scrolling
        }
        
        function handleWordMouseDown(event) {
            // Check if clicking on a word
            const wordElement = event.target.closest('.word');
            if (wordElement) {
                mouseDownTime = Date.now();
                mouseDownPos = { x: event.clientX, y: event.clientY };
                isSelecting = false;
            }
        }
        
        function handleWordMouseUp(event) {
            // Small delay to check if text was selected
            setTimeout(function() {
                const selection = window.getSelection();
                const hasSelection = selection.toString().trim().length > 0;
                
                if (hasSelection) {
                    isSelecting = true;
                    // Text was selected, show selection button
                    handleTextSelection();
                } else {
                    isSelecting = false;
                }
            }, 10);
        }
        
        function handleWordClick(event) {
            // Skip on mobile (uses touch handlers)
            if (isMobileDevice) {
                return;
            }
            
            // Only handle click if it's a quick click (not a selection)
            const clickDuration = Date.now() - mouseDownTime;
            const mouseMove = Math.abs(event.clientX - mouseDownPos.x) + Math.abs(event.clientY - mouseDownPos.y);
            
            // If user moved mouse more than 5px or took more than 300ms, it was a selection, not a click
            if (mouseMove > 5 || clickDuration > 300) {
                return;
            }
            
            // Check if there's a text selection
            const selection = window.getSelection();
            if (selection.toString().trim().length > 0) {
                return; // User was selecting, don't trigger word click
            }
            
            // Check if clicking on a word
            const wordElement = event.target.closest('.word');
            if (wordElement && !isSelecting) {
                const word = wordElement.getAttribute('data-word');
                if (word) {
                    // Decode HTML entities
                    const decodedWord = word.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
                    
                    // Check if this word is adjacent to the last clicked word
                    const isAdjacent = checkIfAdjacent(wordElement, lastClickedWordElement);
                    
                    if (isAdjacent && lastClickedWordElement && currentPhrase.length > 0) {
                        // Add word to current phrase (order will be sorted)
                        currentPhrase.push(decodedWord);
                        currentPhraseElements.push(wordElement);
                        lastClickedWordElement = wordElement;
                        // Highlight the new word
                        highlightWord(wordElement);
                        // Sort phrase to maintain left-to-right reading order
                        sortPhraseLeftToRight();
                        // Get definition for merged phrase (now in correct order)
                        const mergedPhrase = currentPhrase.join(' ');
                        getDefinition(mergedPhrase);
                    } else {
                        // New word (not adjacent), start new phrase
                        // Clear previous highlights
                        clearHighlights();
                        // Start new phrase
                        currentPhrase = [decodedWord];
                        currentPhraseElements = [wordElement];
                        lastClickedWordElement = wordElement;
                        // Highlight the new word
                        highlightWord(wordElement);
                        getDefinition(decodedWord);
                    }
                }
            }
        }
        
        // Clear all highlighted words
        function clearHighlights() {
            highlightedWordElements.forEach(element => {
                if (element) {
                    element.classList.remove('word-highlighted');
                }
            });
            highlightedWordElements = [];
        }
        
        // Highlight a word element
        function highlightWord(element) {
            if (element && !element.classList.contains('word-highlighted')) {
                element.classList.add('word-highlighted');
                highlightedWordElements.push(element);
            }
        }
        
        // Check if two word elements are adjacent in the DOM
        function checkIfAdjacent(currentElement, previousElement) {
            if (!previousElement || !currentElement) {
                return false;
            }
            
            // Must have the same parent
            if (previousElement.parentElement !== currentElement.parentElement) {
                return false;
            }
            
            // Get all word elements from the same parent
            const parent = previousElement.parentElement;
            const allWords = Array.from(parent.querySelectorAll('.word'));
            
            const prevIndex = allWords.indexOf(previousElement);
            const currentIndex = allWords.indexOf(currentElement);
            
            // Adjacent if indices differ by exactly 1
            return Math.abs(currentIndex - prevIndex) === 1;
        }
        
        // Sort phrase and elements to maintain left-to-right reading order
        function sortPhraseLeftToRight() {
            if (currentPhraseElements.length === 0) return;
            
            // Get all word elements from the parent
            const parent = currentPhraseElements[0].parentElement;
            if (!parent) return;
            
            const allWords = Array.from(parent.querySelectorAll('.word'));
            
            // Create array of indices and words
            const phraseWithIndices = currentPhraseElements.map((element, idx) => {
                const index = allWords.indexOf(element);
                return {
                    index: index,
                    word: currentPhrase[idx],
                    element: element
                };
            });
            
            // Sort by DOM index (left to right)
            phraseWithIndices.sort((a, b) => a.index - b.index);
            
            // Update arrays in sorted order
            currentPhrase = phraseWithIndices.map(item => item.word);
            currentPhraseElements = phraseWithIndices.map(item => item.element);
        }
        
        
        function splitIntoPages(text) {
            const lines = text.split('\n');
            pages = [];
            
            for (let i = 0; i < lines.length; i += LINES_PER_PAGE) {
                const pageLines = lines.slice(i, i + LINES_PER_PAGE);
                pages.push(pageLines.join('\n'));
            }
            
            return pages;
        }
        
        function displayPage(pageIndex) {
            if (pageIndex < 0 || pageIndex >= pages.length) return;
            
            // Clear highlights when changing pages
            clearHighlights();
            currentPhrase = [];
            currentPhraseElements = [];
            lastClickedWordElement = null;
            
            currentPage = pageIndex;
            const contentDiv = document.getElementById('content');
            const pageContent = pages[currentPage].trim();
            
            // Check if it's the welcome message and apply special styling
            const isWelcomeMessage = originalText.trim().startsWith('üëã Welcome to Text Reader!');
            if (isWelcomeMessage && pageContent.startsWith('üëã Welcome to Text Reader!')) {
                contentDiv.classList.add('hello-world');
                contentDiv.innerHTML = makeWordsClickable(pageContent);
            } else {
                contentDiv.classList.remove('hello-world');
                contentDiv.innerHTML = makeWordsClickable(pageContent);
            }
            
            // Initialize word click handlers after content is set
            setTimeout(initWordClicks, 0);
            
            // Update pagination controls
            document.getElementById('page-info').textContent = `Page ${currentPage + 1} of ${pages.length}`;
            document.getElementById('prev-btn').disabled = currentPage === 0;
            document.getElementById('next-btn').disabled = currentPage === pages.length - 1;
            
            // Save current page to localStorage
            localStorage.setItem('currentPage', currentPage);
            
            // Scroll to top
            window.scrollTo(0, 0);
        }
        
        function getSavedPage() {
            const savedPage = localStorage.getItem('currentPage');
            if (savedPage !== null) {
                const pageNum = parseInt(savedPage, 10);
                if (!isNaN(pageNum) && pageNum >= 0) {
                    return pageNum;
                }
            }
            return 0; // Default to first page
        }
        
        function previousPage() {
            if (currentPage > 0) {
                displayPage(currentPage - 1);
            }
        }
        
        function nextPage() {
            if (currentPage < pages.length - 1) {
                displayPage(currentPage + 1);
            }
        }
        
        function openGotoPageModal() {
            if (!pages || pages.length === 0) return;
            
            const modal = document.getElementById('goto-page-modal');
            const input = document.getElementById('goto-page-input');
            const hint = document.getElementById('goto-page-hint');
            
            // Set max value and hint
            input.max = pages.length;
            input.value = currentPage + 1;
            hint.textContent = `Enter a page number between 1 and ${pages.length}`;
            
            modal.classList.add('show');
            document.getElementById('menu-overlay').classList.add('show');
            
            // Focus and select the input
            setTimeout(() => {
                input.focus();
                input.select();
            }, 100);
        }
        
        function closeGotoPageModal() {
            document.getElementById('goto-page-modal').classList.remove('show');
            document.getElementById('menu-overlay').classList.remove('show');
        }
        
        function goToPageNumber() {
            const input = document.getElementById('goto-page-input');
            const pageNum = parseInt(input.value);
            
            if (isNaN(pageNum) || pageNum < 1 || pageNum > pages.length) {
                input.style.borderColor = '#d1242f';
                input.focus();
                return;
            }
            
            // Go to the page (pageNum is 1-based, displayPage expects 0-based)
            displayPage(pageNum - 1);
            closeGotoPageModal();
        }
        
        // Allow Enter key to submit in the input (initialize after DOM is ready)
        function initGotoPageInput() {
            const gotoInput = document.getElementById('goto-page-input');
            if (gotoInput) {
                gotoInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        goToPageNumber();
                    }
                });
            }
        }
        
        // Initialize when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initGotoPageInput);
        } else {
            initGotoPageInput();
        }

        // Get selected text
        function getSelectedText() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const selectedText = selection.toString().trim();
                return selectedText;
            }
            return null;
        }
        
        // Detect iOS device
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }
        
        // Show/hide selection button and auto-get definition for multi-word selections
        function handleTextSelection() {
            const selectedText = getSelectedText();
            const btn = document.getElementById('selection-definition-btn');
            
            if (selectedText && selectedText.length > 0) {
                // Check if selection contains multiple words (adjacent words)
                const wordCount = selectedText.trim().split(/\s+/).length;
                const isMultiWord = wordCount > 1;
                
                // If multiple words are selected, automatically get definition
                if (isMultiWord) {
                    // Clean the selected text (remove extra whitespace, keep punctuation for phrases)
                    const cleanText = selectedText.replace(/\s+/g, ' ').trim();
                    if (cleanText) {
                        // On iOS, add a small delay to let native menu appear first
                        const delay = isIOS() ? 400 : 100;
                        
                        setTimeout(() => {
                            // Clear selection first
                            window.getSelection().removeAllRanges();
                            // Hide button (we're auto-triggering)
                            btn.classList.remove('show');
                            // Get definition automatically for merged words
                            getDefinition(cleanText);
                        }, delay);
                        
                        return; // Exit early, don't show button
                    }
                }
                
                // For single word selections, show the button (user can click to get definition)
                // Get selection position
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    const rect = range.getBoundingClientRect();
                    
                    // Calculate button position
                    const buttonWidth = 150; // Approximate button width
                    const buttonHeight = 40;
                    const iosMenuHeight = 50; // iOS selection menu is typically ~50px tall
                    const spacing = 15; // Spacing from selection
                    
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;
                    const isIOSDevice = isIOS();
                    
                    let top, left;
                    
                    if (isIOSDevice) {
                        // On iOS: position button BELOW selection to avoid conflict with iOS menu (which appears above)
                        // Add extra space to account for iOS menu
                        top = rect.bottom + window.scrollY + iosMenuHeight + spacing;
                        
                        // If that would go off screen, try positioning to the right side
                        if (top + buttonHeight > window.scrollY + viewportHeight - 10) {
                            // Position to the right of selection
                            left = rect.right + window.scrollX + spacing;
                            top = rect.top + window.scrollY + (rect.height / 2) - (buttonHeight / 2);
                            
                            // If right side doesn't fit, try left side
                            if (left + buttonWidth > viewportWidth - 10) {
                                left = rect.left + window.scrollX - buttonWidth - spacing;
                                
                                // If left side doesn't fit either, position below but adjust
                                if (left < 10) {
                                    left = rect.left + window.scrollX + (rect.width / 2) - (buttonWidth / 2);
                                    top = rect.bottom + window.scrollY + spacing;
                                    
                                    // Final fallback: position at bottom of viewport
                                    if (top + buttonHeight > window.scrollY + viewportHeight - 10) {
                                        top = window.scrollY + viewportHeight - buttonHeight - 10;
                                    }
                                }
                            }
                        } else {
                            // Position centered horizontally below selection
                            left = rect.left + window.scrollX + (rect.width / 2) - (buttonWidth / 2);
                        }
                    } else {
                        // On desktop: try above first, then below if needed
                        top = rect.top + window.scrollY - buttonHeight - spacing;
                        left = rect.left + window.scrollX + (rect.width / 2) - (buttonWidth / 2);
                        
                        // If selection is near top, show button below instead
                        if (top < window.scrollY + 10) {
                            top = rect.bottom + window.scrollY + spacing;
                        }
                    }
                    
                    // Keep button within viewport horizontally
                    if (left < 10) {
                        left = 10;
                    } else if (left + buttonWidth > viewportWidth - 10) {
                        left = viewportWidth - buttonWidth - 10;
                    }
                    
                    // Ensure button doesn't go below viewport
                    if (top + buttonHeight > window.scrollY + viewportHeight - 10) {
                        top = window.scrollY + viewportHeight - buttonHeight - 10;
                    }
                    
                    // On iOS, add a small delay to let native menu appear first
                    if (isIOSDevice) {
                        setTimeout(() => {
                            btn.style.top = top + 'px';
                            btn.style.left = left + 'px';
                            btn.classList.add('show');
                        }, 200); // 200ms delay to let iOS menu appear
                    } else {
                        btn.style.top = top + 'px';
                        btn.style.left = left + 'px';
                        btn.classList.add('show');
                    }
                }
            } else {
                btn.classList.remove('show');
            }
        }
        
        // Get definition for selected text
        function getDefinitionForSelection(event) {
            // Prevent event from bubbling up
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            const selectedText = getSelectedText();
            console.log('Selected text:', selectedText); // Debug
            
            if (selectedText && selectedText.trim().length > 0) {
                // Clean the selected text (remove extra whitespace, keep punctuation for phrases)
                const cleanText = selectedText.replace(/\s+/g, ' ').trim();
                console.log('Cleaned text:', cleanText); // Debug
                
                if (cleanText) {
                    // Clear selection first
                    window.getSelection().removeAllRanges();
                    // Hide button
                    const btn = document.getElementById('selection-definition-btn');
                    if (btn) {
                        btn.classList.remove('show');
                    }
                    // Get definition
                    getDefinition(cleanText);
                } else {
                    console.warn('No clean text to define');
                }
            } else {
                console.warn('No text selected');
            }
        }
        
        async function getDefinition(word) {
            // Clean the word/phrase (remove extra whitespace, but keep punctuation for phrases)
            // For single words, remove punctuation; for phrases, keep it
            const isPhrase = word.split(/\s+/).length > 1;
            const cleanWord = isPhrase 
                ? word.replace(/\s+/g, ' ').trim()  // Keep spaces and punctuation for phrases
                : word.replace(/[^\w]/g, '');      // Remove punctuation for single words
            
            if (!cleanWord) return;

            const definitionDiv = document.getElementById('definition');
            const contentDiv = document.getElementById('definition-content');
            const wordHeader = document.getElementById('definition-word');
            
            // Set the phrase in header (use currentPhrase if available, otherwise use the word)
            const phrase = currentPhrase.length > 0 ? currentPhrase.join(' ') : cleanWord;
            wordHeader.textContent = phrase;
            
            // Show definition popup
            definitionDiv.classList.remove('hidden');
            definitionDiv.classList.add('show');
            contentDiv.classList.add('loading');
            contentDiv.textContent = 'Loading definition...';

            try {
                // Get the prompt (custom or default) and replace {word} placeholder
                const promptTemplate = getPrompt();
                const prompt = promptTemplate.replace('{word}', cleanWord);
                
                let data;
                
                // Try Netlify function first (for production)
                try {
                    const response = await fetch(DEFINITION_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            word: cleanWord,
                            prompt: prompt
                        })
                    });

                    // Check if response is HTML (means Netlify function doesn't exist - local dev)
                    const contentType = response.headers.get('content-type');
                    if (contentType && contentType.includes('text/html')) {
                        throw new Error('Netlify function not available, using direct API');
                    }

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                        throw new Error(errorData.error || 'Failed to fetch definition');
                    }
                    
                    data = await response.json();
                } catch (error) {
                    // Fallback to direct API call for local development
                    console.log('Using direct Mistral API (local development mode)');
                    
                    const response = await fetch(MISTRAL_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Bearer ' + MISTRAL_API_KEY
                        },
                        body: JSON.stringify({
                            model: 'mistral-tiny',
                            messages: [
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ],
                            max_tokens: 100
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`Mistral API error: ${errorText}`);
                    }
                    
                    data = await response.json();
                }
                
                contentDiv.classList.remove('loading');
                
                if (data.choices && data.choices[0] && data.choices[0].message) {
                    contentDiv.textContent = data.choices[0].message.content;
                } else {
                    contentDiv.textContent = 'Definition not found.';
                }
            } catch (error) {
                contentDiv.classList.remove('loading');
                contentDiv.textContent = 'Error: ' + error.message;
            }
        }

        function closeDefinition() {
            const definitionDiv = document.getElementById('definition');
            definitionDiv.classList.remove('show');
            definitionDiv.classList.add('hidden');
            // Reset phrase when closing
            currentPhrase = [];
            currentPhraseElements = [];
            lastClickedWordElement = null;
            // Clear highlights
            clearHighlights();
        }

        // Close definition when tapping outside (mobile-friendly)
        document.addEventListener('click', function(event) {
            const definitionDiv = document.getElementById('definition');
            const selectionBtn = document.getElementById('selection-definition-btn');
            
            // Don't process clicks on selection button - it handles its own click
            if (event.target === selectionBtn || event.target.closest('#selection-definition-btn')) {
                return;
            }
            
            if (definitionDiv.classList.contains('show') && 
                !definitionDiv.contains(event.target) && 
                !event.target.classList.contains('word')) {
                closeDefinition();
            }
            
            // Hide selection button if clicking outside content area and selection button
            if (!event.target.closest('#content') && !event.target.closest('#selection-definition-btn')) {
                if (selectionBtn) {
                    selectionBtn.classList.remove('show');
                }
            }
        });
        
        // Handle text selection
        document.addEventListener('mouseup', handleTextSelection);
        document.addEventListener('touchend', function() {
            // On iOS, wait longer to let native selection menu appear first
            const delay = isIOS() ? 300 : 100;
            setTimeout(handleTextSelection, delay);
        });
        
        // Handle selectionchange for both showing and hiding button
        document.addEventListener('selectionchange', function() {
            // Small delay to ensure selection is fully established
            setTimeout(function() {
                const selectedText = getSelectedText();
                if (selectedText && selectedText.length > 0) {
                    handleTextSelection();
                } else {
                    // Selection cleared, hide button
                    document.getElementById('selection-definition-btn').classList.remove('show');
                }
            }, isIOS() ? 350 : 150);
        });
        
        // Hide selection button on scroll
        window.addEventListener('scroll', function() {
            document.getElementById('selection-definition-btn').classList.remove('show');
        });
        
        // Initialize selection button event listener
        function initSelectionButton() {
            const selectionBtn = document.getElementById('selection-definition-btn');
            if (selectionBtn) {
                // Add click event listener (in addition to onclick for better reliability)
                selectionBtn.addEventListener('click', function(event) {
                    event.preventDefault();
                    event.stopPropagation();
                    getDefinitionForSelection(event);
                });
                
                // Prevent event bubbling on mousedown
                selectionBtn.addEventListener('mousedown', function(event) {
                    event.stopPropagation();
                });
            }
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initSelectionButton);
        } else {
            initSelectionButton();
        }

        // Check if there's imported text in localStorage
        let showWelcome = true;
        try {
            const importedText = localStorage.getItem('importedText');
            if (importedText) {
                // Try to load imported text
                try {
                    loadText(importedText);
                    showWelcome = false;
                } catch (error) {
                    console.error('Error loading text:', error);
                    // Clear potentially corrupted data
                    try {
                        localStorage.removeItem('importedText');
                    } catch (e) {
                        // Ignore errors when clearing
                    }
                }
            }
        } catch (error) {
            console.error('Error accessing localStorage:', error);
        }
        
        if (showWelcome) {
            // Show default welcome text
            // Show default welcome text
            const helloWorldText = `üëã Welcome to Text Reader! üìö

üéâ Congratulations! You've discovered the most interactive reading experience since... well, ever!

üìñ What is this app?
This is your personal reading companion that makes every word clickable and smart. Think of it as having a dictionary that lives inside your text, but way cooler! ü§ì

‚ú® Key Features:
‚Ä¢ üìù Read any text file or PDF
‚Ä¢ üñ±Ô∏è Click any word to get instant AI-powered definitions
‚Ä¢ üì± Works beautifully on your phone, tablet, or computer
‚Ä¢ üìë Automatic pagination with quick page navigation
‚Ä¢ üíæ Your reading position is saved automatically
‚Ä¢ ‚öôÔ∏è Customize everything to your liking

üöÄ How to Get Started:

1Ô∏è‚É£ Click the ‚öôÔ∏è gear icon (top-right) to open Settings
2Ô∏è‚É£ Choose "Import Text" to upload your own .txt or .pdf file
3Ô∏è‚É£ Start reading! Click any word you're curious about
4Ô∏è‚É£ Use the Previous/Next buttons at the bottom to navigate long texts
5Ô∏è‚É£ Click the page number (e.g., "Page 1 of 10") to jump to any page

üí° Pro Tips:
‚Ä¢ The settings button hides when you scroll down (so it doesn't distract you!)
‚Ä¢ Your current page is remembered even after refresh
‚Ä¢ You can customize the AI prompt in Settings ‚Üí AI Prompt Settings
‚Ä¢ Export your text anytime to save it locally

üéØ Ready to dive in? Import a file and start exploring! Every word is just a click away from revealing its secrets! üîç‚ú®

Happy Reading! üìñüíô`;
            originalText = helloWorldText;
            loadText(helloWorldText);
        }
        
        // Auto-hide settings button and definition on scroll - only show at top
        const settingsBtn = document.getElementById('settings-btn');
        let lastScrollTop = 0;
        
        window.addEventListener('scroll', function() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const definitionDiv = document.getElementById('definition');
            
            // Show button only when at the very top (scrollTop === 0)
            if (scrollTop === 0) {
                settingsBtn.classList.remove('hidden');
            } 
            // Hide button immediately when user starts scrolling down
            else {
                settingsBtn.classList.add('hidden');
                // Also close menu if open
                closeSettingsMenu();
            }
            
            // Hide definition when scrolling down
            if (definitionDiv.classList.contains('show')) {
                if (scrollTop > lastScrollTop && scrollTop > 50) {
                    // Scrolling down - hide definition
                    definitionDiv.classList.add('hidden');
                } else if (scrollTop < lastScrollTop || scrollTop <= 50) {
                    // Scrolling up or at top - show definition if it was visible
                    definitionDiv.classList.remove('hidden');
                }
            }
            
            lastScrollTop = scrollTop;
        }, false);
        
        // Also check on page load to ensure button is visible at top
        window.addEventListener('load', function() {
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            if (scrollTop === 0) {
                settingsBtn.classList.remove('hidden');
            }
        });
    </script>
</body>
</html>